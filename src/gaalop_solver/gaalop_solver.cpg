#include <iostream>
#include <cmath>
#include "proxy.h"

#define float double
#define abs fabs
#define sqrtf sqrt

#define radians(angleDegrees) (angleDegrees * M_PI / 180.0)
#define degrees(angleRadians) (angleRadians * 180.0 / M_PI)

extern "C"
void solveIK(
             const VectorPx& _shoulder,
             const VectorPx& _elbow,
             const VectorPx& _wrist,
             const VectorPx& _goal,
             const VectorPx& _pole,
             QuaternionPx& o_elbowRot,
             QuaternionPx& o_shoulderRot
             /*
             const double _twist,
             */
            )
{
#pragma gpc begin
  typedef double freal;

  freal sx = _shoulder.x;
  freal sy = _shoulder.y;
  freal sz = _shoulder.z;

  freal ex = _elbow.x;
  freal ey = _elbow.y;
  freal ez = _elbow.z;

  freal wx = _wrist.x;
  freal wy = _wrist.y;
  freal wz = _wrist.z;

  freal gx = _goal.x;
  freal gy = _goal.y;
  freal gz = _goal.z;

  freal px = _pole.x;
  freal py = _pole.y;
  freal pz = _pole.z;
  
  #pragma clucalc begin
  // setting up the initial vectors
  ?v_S = sx*e1 + sy*e2 + sz*e3; // shoulder vector
  ?v_E = ex*e1 + ey*e2 + ez*e3; // elbow vector
  ?v_W = wx*e1 + wy*e2 + wz*e3; // wrist vector
  ?v_G = gx*e1 + gy*e2 + gz*e3; // goal vector
  ?v_P = px*e1 + py*e2 + pz*e3; // pole vector

  // compute distances
  v_SE = v_E - v_S;
  v_EW = v_W - v_E;
  v_SW = v_W - v_S;
  v_SG = v_G - v_S;
  ?se_d = sqrt(abs(v_SE*v_SE)); // upper arm length
  ?ew_d = sqrt(abs(v_EW*v_EW)); // lower arm length
  ?sw_d = sqrt(abs(v_SW*v_SW)); // shoulder-wrist distance
  ?sg_d = sqrt(abs(v_SG*v_SG)); // shoulder-goal distance
  
  // elbow axis
  ?I3 = e1^e2^e3; // Euclidean pseudoscalar
  v_SE_n = v_SE / se_d;
  v_EW_n = v_EW / se_d;
  ?v_Axis_e = -(v_SE_n^v_EW_n)*I3; // orthogonal rotation axis
  ?cos_E0 = v_SE_n.v_EW_n; // cosine of initial elbow angle
  #pragma clucalc end

  // elbow extension angle using the law of cosines
  freal cos_E = (sg_d*sg_d - se_d*se_d - ew_d*ew_d)/(2.0*se_d*ew_d);
  if (cos_E > 1) cos_E = 1;
  if (cos_E < -1) cos_E = -1;
  freal angle_E = acos(cos_E);

  // initial elbow angle
  freal angle_E0;
  if (cos_E0 <= -1.0)
    angle_E0 = M_PI;
  else if (cos_E0 >= 1.0)
    angle_E0 = 0.0;
  else
    angle_E0 = acos(cos_E0);

  // elbow half angle
  freal theta = (angle_E - angle_E0)/2.0;
  // calculating the final elbow quaternion
  freal q_Ex = v_Axis_e[0]*sin(theta);
  freal q_Ey = v_Axis_e[1]*sin(theta);
  freal q_Ez = v_Axis_e[2]*sin(theta);
  freal q_Ew = cos(theta);
  o_elbowRot = QuaternionPx(q_Ex, q_Ey, q_Ez, q_Ew);

  #pragma clucalc begin
  // setting up the initial points
  ?p_S = VecN3(sx, sy, sz); // shoulder point
  ?p_E = VecN3(ex, ey, ez); // elbow point
  p_W = VecN3(wx, wy, wz); // wrist point
  p_G = VecN3(gx, gy, gz); // goal point
  p_P = VecN3(px, py, pz); // pole point

  //if (dg <= (ds+dw)) {
  //  ?P_G=VecN3(gx, gy, gz); // goal point
  //} else {
  //  P_GN = (v_G)*(ds+dw)/dg; // corrected goal vector
  //  ?P_G = P_GN + 0.5*P_GN*P_GN*einf + e0; // corrected goal point
  //}

  // compute goal elbow point
  s_S = p_S - 0.5*se_d*se_d*einf; // shoulder sphere
  s_G = p_G - 0.5*ew_d*ew_d*einf; // goal sphere
  c_E = s_S^s_G;
  // swivel intersection plane
  pl_Swivel = *(p_P^p_G^p_S^einf);
  // determine which point to pick
  pp_E=*(c_E^pl_Swivel);
  // flip the sign of the square root to get the second point
  ?p_EG = (sqrt(abs(pp_E.pp_E)) - pp_E) / (einf.pp_E);
  ?p_EG1 = (-sqrt(abs(pp_E.pp_E)) - pp_E) / (einf.pp_E);

  // shoulder YZ quaternion
  pl_Mid = p_E - p_EG;
  pl_Elbow = *(p_S^p_E^p_EG^einf);
  l_Mid = pl_Elbow^pl_Mid;
  l_MidN = sqrt(abs(l_Mid.(~l_Mid)));
  // YZ shoulder rotation quaternion
  ?q_12 = l_Mid / l_MidN;
  // X rotation cosine
  p_WR = q_12*p_W*(~q_12);
  l_EG = *(p_EG^p_G^einf) / ew_d;
  pl_YZ = *(p_WR^p_EG^p_S^einf);
  yz_n = sqrt(abs(pl_YZ.(~pl_YZ)));
  swivel_n = sqrt(abs(pl_Swivel.(~pl_Swivel)));
  ?pl_Swivel_n = pl_Swivel / swivel_n;
  ?pl_YZ_n = pl_YZ / yz_n;
  #pragma clucalc end
  freal v_EGx = mv_get_bladecoeff(p_EG, e1);
  freal v_EGy = mv_get_bladecoeff(p_EG, e2);
  freal v_EGz = mv_get_bladecoeff(p_EG, e3);

  freal v_Swivelx = mv_get_bladecoeff(pl_Swivel_n, e1);
  freal v_Swively = mv_get_bladecoeff(pl_Swivel_n, e2);
  freal v_Swivelz = mv_get_bladecoeff(pl_Swivel_n, e3);

  freal v_YZx = mv_get_bladecoeff(pl_YZ_n, e1);
  freal v_YZy = mv_get_bladecoeff(pl_YZ_n, e2);
  freal v_YZz = mv_get_bladecoeff(pl_YZ_n, e3);
  #pragma clucalc begin
  v_EG = v_EGx*e1 + v_EGy*e2 + v_EGz*e3;
  v_Swivel = v_Swivelx*e1 + v_Swively*e2 + v_Swivelz*e3;
  v_YZ = v_YZx*e1 + v_YZy*e2 + v_YZz*e3;
  cross = -(v_Swivel^v_YZ)*I3;
  ?sin_thetax = sqrt(abs(cross*cross));
  ?cos_thetax = v_Swivel.v_YZ;
  ?q_sign = (v_EG - v_S).cross;
  #pragma clucalc end
  freal thetax = atan2(sin_thetax, cos_thetax);
  if (q_sign < 0.0)
    thetax = -thetax;
  freal q_3_cos = cos(0.5*thetax);
  freal q_3_sin = sin(0.5*thetax);
  #pragma clucalc begin
  //?cos_x = (pl_YZ.pl_Swivel) / (yz_n*swivel_n);
  ?l_SE = *(p_S^p_E^einf) / se_d;
  // Y shoulder rotation quaternion
  //?q_3 = sqrt(0.5*(1+cos_x)) + sqrt(0.5*(1-cos_x))*l_SE;
  q_3 = q_3_cos + q_3_sin*l_SE;
  ?q_S = q_12*(~q_3);
  #pragma clucalc end
  if (!(_wrist == _goal))
  {
    // shoulder quaternion output
    o_shoulderRot.x = -mv_get_bladecoeff(q_S, e2^e3);
    o_shoulderRot.y = mv_get_bladecoeff(q_S, e1^e3);
    o_shoulderRot.z = -mv_get_bladecoeff(q_S, e1^e2);
    o_shoulderRot.w = mv_get_bladecoeff(q_S, 1);
  }
  else
  {
    o_shoulderRot.x = 0;
    o_shoulderRot.y = 0;
    o_shoulderRot.z = 0;
    o_shoulderRot.w = 1;
  }
  // Debugging Information
  
  std::cout << "Solved Elbow: ";
  std::cout << p_EG[0] << ", ";
  std::cout << p_EG[1] << ", ";
  std::cout << p_EG[2];
  std::cout << std::endl;

  std::cout << "Alternative Elbow: ";
  std::cout << p_EG1[0] << ", ";
  std::cout << p_EG1[1] << ", ";
  std::cout << p_EG1[2];
  std::cout << std::endl;

  std::cout << "X Angle: " << thetax << std::endl;

  std::cout << "-------------------------------------------------------------";
  std::cout << std::endl;
#pragma gpc end
}
